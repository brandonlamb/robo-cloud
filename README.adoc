== robo-cloud

A robocode like client-server based framework.

=== Motivation

I have always enjoyed playing with robocode on the earlier 2000s. And I found a bit odd that I could never really find a natural successor
to it designed to run on a client/server mode.

This project is a take on what could be such sucessor.

A lot of the ideas here in this project came from either my memory of robocode or this https://www.ibm.com/developerworks/library/j-robocode/index.html[great article] that presents the project.

Not everything was translated as it is in terms of functionality.

=== Design principles

I chose https://grpc.io[gRPC] as the protocol to implement the server, this would allow robots to be implemented on any language that supports
gRPC.

The `common` project has the `Robot.proto` file with all the messages and services, but the bot really need to use one method

[protobuf]
----
service GameService {
    rpc connect(stream Action) returns (stream FrameUpdate);
}
----

We use a bi-directional stream. Robots stream `actions` based on `frameUpdates` they receive from the server.

==== The GameService

The server handle all the updates to the internal state of the robots (such as positions, collision detection, hits, health, bearing of the robot)
If an event is detected, for example, if a robot is hit by another robot projectile, the server streams that as an `HIT_BY_ENEMY_EVENT`, if the bot
collides with another body (robot or wall) then it sends `COLLISION_DETECTED_EVENT`.

All events are mapped on the proto file. The server will manager the battlefield, starting and stopping the battle upon a winner is declared.

==== The Robot client
The bots are responsible to implement code that reacts on events sent by the server. And all they can do is send messages of type `ACTION`

each action is defined as:

[protobuf]
----

message Action {
    int64 timestamp = 1;
    string id = 2;
    ActionType actionType = 3;
    double value = 4;
}

enum ActionType {
    JOIN = 0;
    ROTATE = 1;
    THROTTLE = 2;
    FIRE = 3;
    LEAVE = 4;
}

----

So let's pretend we are writing a bot that spins around clockwise and when it detects an enemy it fires the cannon:

[kotlin]
-----
val so: StreamObserver<FrameUpdate> = object : StreamObserver<FrameUpdate> {
        override fun onNext(value: FrameUpdate?) {
            onFrame(value!!)
        }

        override fun onError(t: Throwable?) {
        }

        override fun onCompleted() {
        }

    }

fun onFrame(frame: FrameUpdate){
        lastFrame = frame

        if(frame.eventType == EventType.ENEMY_DETECTED) {
            client.onNext(Action.newBuilder()
                                              .setActionType(ActionType.FIRE)
                                              .setValue(1.0)
                                              .setTimestamp(System.currentTimeMillis())
                                              .build())
        }

    }
-----

The server queues up the actions and during it's main loop (runs about 30 times per second) it reacts by updating the state of each one
of the robots. If another event is generated by the change in the world it writes the event back.

=== Status

There's 3 main projects

* common: Hosts the proto files, you will need to make sure you `generateProto` task before trying to build the other projects as they depend on generated code from this one
* core: Core server. Starts the game engine inside a ktor/kodein web server. The goal is to allow a web admin interface to start/stop the GameService
* common-bots: A few sample bots for people to play with

The desired state is described above, but there's a ton of moving things to take care of. I'll try to keep the following table up-to-date

|========
| Feature | Status
| Proto API | Unstable
| Main Game Loop | Working
| Enemy detection | Working
| Collision Detection | Not implemented
| Match detection and state | Not implemented
| Websockets canvas viewer | Basic implementation
| Configurable GRPC server with lifecycle | Not implemented